===== REPO: bst-sem-proj =====
URL: https://github.com/SaudDSxAI/bst-sem-proj

--- README ---
# Binary Search Tree (BST) in C++

## Overview
This project implements a Binary Search Tree (BST) in C++. It supports insertion, deletion, and multiple tree traversals (inorder, preorder, postorder). The project demonstrates fundamental data structure concepts and recursive algorithms, reflecting my journey in mastering C++ and core computer science principles.

## Features
- **Node Insertion:** Add new nodes to the BST while maintaining its properties.
- **Node Deletion:** Remove nodes (leaf, one child, or two children) with correct tree restructuring.
- **Traversals:**
  - Inorder (Left, Root, Right)
  - Preorder (Root, Left, Right)
  - Postorder (Left, Right, Root)
- **Find Minimum:** Utility to find the minimum value node in a subtree.
- **Interactive Console:** User inputs data for insertion and deletion, with results displayed after each operation.

## How It Works
1. **Insert Nodes:** User enters values, which are inserted into the BST.
2. **Display Tree:** Inorder traversal prints the tree contents.
3. **Delete Node:** User specifies a value to delete; the tree is updated and displayed again.

## My Learning Journey
Through this project, I learned:
- The structure and properties of binary search trees.
- Recursive programming for tree operations.
- Handling edge cases in node deletion.
- The importance of clear, modular code for data structures.

## Usage Instructions
1. **Compile:** Use a C++ compiler (e.g., g++) to compile `mybst.cpp`.
   - Example: `g++ mybst.cpp -o bst`
2. **Run:** Execute the compiled program.
   - Example: `./bst`
3. **Follow Prompts:** Enter node values to build the tree, then specify a node to delete.

## File Structure
- `Binary_search_tree/mybst.cpp`: Main source code for the BST implementation.
- `README.md`: Project overview, features, and instructions.

---
*Created by Saud Ahmad – Data Structures Learner*

--- END README ---
===== END REPO =====

===== REPO: address-book-sem-proj =====
URL: https://github.com/SaudDSxAI/address-book-sem-proj

--- README ---
Contact Management System using Binary Search Tree (BST) in C++

This project implements a Contact Management System in C++ that uses a Binary Search Tree (BST) as the core data structure. It demonstrates advanced data structure manipulation skills, including insertion, deletion, updating, searching, and file handling.

Overview

This program allows users to manage contact information efficiently by leveraging the BST structure. Each contact contains:

Name

Address

Phone Number

Email

The BST ensures that data operations (insert, delete, search) are performed efficiently, while file handling guarantees persistence between program runs.

Features

Add Contact

Append new contact details to the database (example.txt) and store in BST.

Delete Contact

Remove a specific contact from the BST and update the file.

Handles cases where the node has zero, one, or two children.

Update Contact

Update contact information by searching the BST.

Changes are automatically reflected in the file.

Show All Contacts

Display all contacts in sorted order using in-order traversal of BST.

Search Contact

Search for a contact by name efficiently using BST traversal.

File Persistence

All contacts are stored in example.txt.

Program automatically reads from and writes to the file.

Data Structure Skills Demonstrated

BST implementation with recursive insertion, deletion, and traversal.

Handling edge cases for deletion (leaf, one child, two children).

Efficient in-order traversal to maintain sorted data.

File I/O integration with BST for persistent storage.

How It Works

On program start, the file example.txt is read, and contacts are loaded into a BST.

The user is presented with a menu to add, delete, update, show, or search contacts.

Each operation updates both the BST in memory and the file for persistence.

Searching and insertion operations take advantage of BST properties for O(log n) performance on average.

Data Structure Highlights

Binary Search Tree

Each node contains a contact’s name as the key and pointers to left/right children.

BST property ensures that all left children < node < right children, enabling efficient search and sorted output.

File Integration

Supports reading and writing from a file while maintaining BST structure.

Ensures that updates, deletions, and insertions persist across sessions.

Recursive Algorithms

Recursive insertion, deletion, traversal, and search demonstrate mastery of recursion in data structures.

--- END README ---
===== END REPO =====

===== REPO: agentic-ai =====
URL: https://github.com/SaudDSxAI/agentic-ai

--- README ---
# Agentic AI Projects
**Autonomous, intelligent agents in action—experimentation, learning, and real-world automation.**
This repository showcases an evolving collection of **Agentic AI projects**—autonomous agents built for real-world tasks using modern AI frameworks. Each project demonstrates a unique capability, from web scraping to resume parsing and conversational agents, designed as foundations for future innovation.

## Projects Overview

- **agentic-webscraper** – Autonomous web-crawling agent capable of fetching and parsing content from target websites.
- **first-resume-parser** – A prototype parser to extract structured resume information (e.g., emails, names, skills).
- **phidata-resume-parser** – An advanced version, built with more robustness, data handling, or feature enhancements.
- **langchain-assistant** – Agent built using LangChain for multi-step workflows, tool integration, and memory.
- **langgraph-chatbot** – Chat agent with stateful workflows and branching logic, powered by LangGraph.
- **seerah-assistant** – Domain-specific assistant (e.g., for Seerah content), showcasing contextual QA or task execution.

## Key Themes & Frameworks

- **Agentic AI paradigms**: autonomous reasoning, tool integration, memory, and iterative workflows.
- **LangChain & LangGraph**: building blocks for multimodal, memory-augmented, multi-step agents.  
  - LangChain empowers agents with tools, memory, and prompt chaining. :contentReference[oaicite:2]{index=2}  
  - LangGraph enables stateful, directed-graph workflows—ideal for orchestrating complex agent behavior. :contentReference[oaicite:3]{index=3}
- **Real-world relevance**: These agents align with the evolving landscape of autonomous AI systems, observable in frameworks like OpenAI Agents SDK (multi-agent orchestration with tracing) :contentReference[oaicite:4]{index=4} and industry trends of replacing static models with adaptable agents. :contentReference[oaicite:5]{index=5}

--- END README ---
===== END REPO =====

===== REPO: cv-entry-system =====
URL: https://github.com/SaudDSxAI/cv-entry-system

--- README ---
# Access Vision: Computer Vision Entry System

Welcome to Access Vision! This project documents my journey in building a computer vision-based entry and exit management system for institutions. The system integrates face recognition, sensor data, real-time visualization, and automated data logging to streamline and secure access control.

## Project Overview
- **Goal:** Automate and monitor entry/exit of individuals using face recognition and sensor data.
- **Technologies:** Python, OpenCV, face_recognition, pywinauto, pandas, matplotlib
- **Key Features:**
  - Real-time face recognition using camera feeds
  - Integration with ultrasonic sensors via serial communication
  - Automated logging of entry/exit events to CSV
  - Data visualization of access patterns
  - GUI automation for serial terminal control

## System Components
- **recognizer.py:** Face encoding and recognition logic
- **capture.py:** Camera capture, face detection, and data extraction
- **in_out.py:** Main workflow for reading sensor data, triggering recognition, logging events, and visualization
- **visual.py:** Real-time visualization of entry/exit data
- **Students_Data.csv:** Stores all access records for analysis

## How It Works
1. The system listens for sensor triggers (Entry/Exit) via a serial terminal (CoolTerm).
2. On trigger, it captures a face image, recognizes the individual, and logs the event (name, reg number, time, date, batch, faculty).
3. All events are appended to a CSV file for record-keeping.
4. Real-time bar charts visualize the number of entries and exits per student.

## Key Learnings & Challenges
- Integrating hardware (sensors) with software workflows
- Real-time face recognition and handling unknown faces
- Automating GUI interactions for serial communication
- Ensuring robust data logging and visualization
- Troubleshooting camera, sensor, and file I/O issues

## How to Run
1. Install required packages:
   ```bash
   pip install opencv-python face_recognition pywinauto pandas matplotlib
   ```
2. Update file paths as needed in the scripts.
3. Connect cameras and sensors, and start the serial terminal (CoolTerm).
4. Run `in_out.py` to launch the system.

## About This Project
This project reflects my hands-on struggle and growth in computer vision, hardware integration, and real-time data analysis. It demonstrates a complete workflow from sensor input to actionable insights.

---

Thank you for exploring Access Vision!

--- END README ---
===== END REPO =====

===== REPO: bus-reservation-sem-proj =====
URL: https://github.com/SaudDSxAI/bus-reservation-sem-proj

--- README ---
# Bus Reservation System in C++

## Overview
This project is a console-based bus reservation system implemented in C++. It allows users to add new buses, reserve seats, view bus details, and check available buses. The project demonstrates object-oriented programming concepts, array manipulation, and user interaction through a menu-driven interface. It reflects my journey in learning C++ and building practical, real-world applications.

## Features
- **Add Bus:** Register new buses with details like bus number, driver, arrival/departure times, and route.
- **Seat Reservation:** Reserve seats for passengers, ensuring no double-booking.
- **Show Bus Details:** View all details and reserved seats for a specific bus.
- **Available Buses:** List all buses with their details and available seats.
- **User-Friendly Menu:** Simple menu-driven interface for easy navigation.

## How It Works
1. **Add Bus:** Enter bus and driver details; all seats are initialized as empty.
2. **Reserve Seat:** Select a bus and seat number, then enter the passenger's name to reserve.
3. **Show Details:** Enter a bus number to view its details and reserved seats.
4. **Available Buses:** Display all registered buses and their routes.
5. **Exit:** Quit the program.

## My Learning Journey
Through this project, I learned:
- The basics of classes, arrays, and functions in C++.
- How to design and implement a menu-driven application.
- Managing data and user input validation.
- The importance of modular code and clear user feedback.

## Usage Instructions
1. **Compile:** Use a C++ compiler (e.g., g++) to compile `2021576_Saud_.cpp`.
   - Example: `g++ 2021576_Saud_.cpp -o bus_reservation`
2. **Run:** Execute the compiled program.
   - Example: `./bus_reservation`
3. **Follow Menu:** Use the on-screen menu to add buses, reserve seats, and view details.

## File Structure
- `Bus_reservation_system/2021576_Saud_.cpp`: Main source code for the bus reservation system.
- `README.md`: Project overview, features, and instructions.

---
*Created by Saud Ahmad – C++ Programming Learner*

--- END README ---
===== END REPO =====

===== REPO: data-mining =====
URL: https://github.com/SaudDSxAI/data-mining

--- README ---
# Data Mining Lab: My Learning Journey

Welcome to my Data Mining Lab repository! This collection of notebooks documents my hands-on journey through data mining, data analysis, and machine learning concepts. Each notebook explores a different topic, dataset, or technique, helping me build practical skills and deepen my understanding of data science.

## Repository Structure
```
data-mining/
├── pandas_journey.ipynb         # Learning and exploring pandas basics
├── Lab4_task.ipynb              # Lab 4: Data mining tasks and solutions
├── Lab-08-DNN Bootcamp.ipynb    # Deep Neural Networks bootcamp exercises
├── LAb_5.ipynb                  # Lab 5: More data mining tasks
├── code.ipynb                   # Miscellaneous code and experiments
├── README.md                    # This file
```

## Notebooks Overview
- **pandas_journey.ipynb**: My step-by-step exploration of pandas, including data loading, inspection, selection, filtering, and manipulation using real survey data and custom examples.
- **Lab4_task.ipynb**: Solutions and experiments for Lab 4, focusing on practical data mining problems.
- **Lab-08-DNN Bootcamp.ipynb**: Hands-on exercises with deep neural networks, covering model building, training, and evaluation.
- **LAb_5.ipynb**: Additional lab tasks, reinforcing key data mining concepts.
- **code.ipynb**: A scratchpad for miscellaneous code, quick tests, and extra practice.

## Key Learnings
- How to use pandas for efficient data analysis and manipulation
- Data cleaning, exploration, and visualization techniques
- Building and evaluating machine learning and deep learning models
- Applying theoretical concepts to real-world datasets

## How to Use
1. Make sure you have Python and the required libraries installed:
   ```bash
   pip install pandas numpy matplotlib scikit-learn tensorflow
   ```
2. Open any notebook in Jupyter Notebook or VS Code.
3. Run the cells sequentially to follow the learning process and experiment with the code.

## About This Repository
This repository is a reflection of my progress and curiosity in data science. It serves as both a personal learning log and a resource for others interested in data mining and machine learning.

---

Happy learning and exploring!
--- END README ---
===== END REPO =====

===== REPO: alu-proteus =====
URL: https://github.com/SaudDSxAI/alu-proteus

--- README ---
# ALU & Multiplier Circuit – Proteus Simulation Project

## Overview
This project implements an Arithmetic and Logic Unit (ALU) with an integrated multiplier circuit, designed and simulated using Proteus. The goal is to understand digital logic design, circuit simulation, and the practical aspects of building a core computational component for CPUs. This project reflects my journey in digital systems, from theoretical concepts to hands-on simulation and testing.

## Features
- **ALU Operations:** Supports basic arithmetic (addition, subtraction) and logic (AND, OR, XOR, NOT) functions.
- **Multiplier Circuit:** Performs binary multiplication as part of the ALU.
- **Proteus Simulation:** Visualizes and tests the circuit in a virtual environment, allowing for rapid prototyping and debugging.
- **Modular Design:** Each operation is implemented as a separate module for clarity and extensibility.

## How It Works
1. **Design:** The ALU and multiplier are designed using digital logic gates and combinational circuits.
2. **Simulation:** The complete circuit is built and tested in Proteus (`proteus_file.pdsprj`).
3. **Testing:** Various input combinations are applied to verify correct operation of all ALU functions and the multiplier.
4. **Analysis:** Simulation results are analyzed to ensure accuracy and performance.

## My Learning Journey
Through this project, I learned:
- The fundamentals of ALU architecture and digital logic design.
- How to implement and test combinational circuits in Proteus.
- The importance of modular design for complex digital systems.
- Debugging and validating digital circuits in a simulation environment.

## Usage Instructions
1. Open `proteus_file.pdsprj` in Proteus Design Suite.
2. Explore the schematic to understand the ALU and multiplier structure.
3. Run the simulation and test different input values to observe the outputs.
4. Modify or extend the design to add more operations or features as desired.

## File Structure
- `proteus_file.pdsprj`: Main Proteus project file containing the ALU and multiplier circuit.
- `README.md`: Project overview, features, and instructions.

---
*Created by Saud Ahmad – Digital Systems Enthusiast*

--- END README ---
===== END REPO =====

===== REPO: deep-learning =====
URL: https://github.com/SaudDSxAI/deep-learning

--- README ---
# Deep Learning Project: Breast Cancer Classification

Welcome to my deep learning project! This notebook documents my journey in building, training, and evaluating a neural network for breast cancer classification using the popular sklearn breast cancer dataset. Here, I share my process, challenges, and key learnings as I explore deep learning for real-world medical data.

## Project Overview
- **Goal:** Classify tumors as malignant or benign using deep learning.
- **Dataset:** sklearn.datasets.load_breast_cancer (features and labels)
- **Techniques:** Data exploration, preprocessing, neural network modeling, training, evaluation, and prediction.

## Notebook Highlights
- Data loading and conversion to pandas DataFrame
- Exploratory data analysis: info, describe, missing values, value counts
- Data splitting into train and test sets
- Neural network model building with TensorFlow/Keras
- Training with and without feature standardization
- Visualization of accuracy and loss curves
- Model evaluation and prediction on test data

## Key Learnings
- The importance of data preprocessing and standardization for neural networks
- How to design and train a multi-layer neural network for binary classification
- Interpreting model performance using accuracy and loss plots
- Practical experience with TensorFlow/Keras in a real-world context

## How to Run
1. Make sure you have Python, pandas, scikit-learn, matplotlib, and TensorFlow installed:
   ```bash
   pip install pandas scikit-learn matplotlib tensorflow
   ```
2. Open `breast_cancer .ipynb` in Jupyter Notebook or VS Code.
3. Run the cells sequentially to follow the workflow and experiment with the code.

## About This Project
This notebook is a reflection of my learning process in deep learning and medical data analysis. It demonstrates the end-to-end workflow from data loading to model evaluation and prediction.

---

Thank you for exploring my deep learning journey!

--- END README ---
===== END REPO =====

===== REPO: data-science-proj =====
URL: https://github.com/SaudDSxAI/data-science-proj

--- README ---
# Data Science Project: Traffic Accident Analysis

## Overview
This project analyzes traffic accident data from Pakistan using Python and pandas. The goal is to extract meaningful insights about accident frequency, injuries, and fatalities across different regions and years. The code demonstrates data aggregation, filtering, and summary statistics, reflecting my journey in learning data wrangling and exploratory data analysis.

## Features
- **Data Aggregation:** Summarizes total accidents, injuries, and fatalities for each region (Pakistan, Punjab, Sindh, Khyber Pakhtunkhwa, Balochistan, Islamabad).
- **Maximum/Minimum Analysis:** Identifies the years with the highest and lowest number of accidents.
- **Tabular Output:** Presents results in a clear, readable table using pandas DataFrame.
- **Reproducible Workflow:** Code is modular and easy to adapt for other datasets or regions.

## How It Works
1. **Data Loading:** Reads a CSV file containing traffic accident data.
2. **Filtering:** Extracts data for each region using boolean masks.
3. **Summarization:** Calculates total accidents, injuries, and fatalities for each region.
4. **Tabulation:** Combines results into a summary DataFrame and prints it.
5. **Insights:** Prints the years with maximum and minimum accidents for further analysis.

## My Learning Journey
Through this project, I learned:
- How to use pandas for data filtering, aggregation, and tabular presentation.
- The importance of data cleaning and validation.
- Extracting actionable insights from real-world datasets.
- Presenting results in a clear, interpretable format.

## Usage Instructions
1. Place the dataset (`Pakistani_Traffic_Accidents.csv`) in the specified directory or update the file path in the code.
2. Run `Q1.py` to generate the summary table and key statistics.
3. Review the printed output for insights on accident trends by region and year.

## File Structure
- `Q1.py`: Main analysis script for traffic accident data.
- `Pakistani_Traffic_Accidents.csv`: Input dataset (not included).

---
*Created by Saud Ahmad – Data Science Enthusiast*
--- END README ---
===== END REPO =====

===== REPO: dsa-implementation =====
URL: https://github.com/SaudDSxAI/dsa-implementation

--- README ---
# Data Structures in C++: My Practice & Learning Journey

Welcome to my Data Structures in C++ repository! This collection of C++ programs documents my hands-on practice and understanding of fundamental and advanced data structures. Each file demonstrates a different structure or concept, with detailed implementations and comments to reinforce my learning.

## Repository Structure
```
data_structures_c/
├── stack.cpp              # Stack (singly linked list, push/pop)
├── queue.cpp              # Queue (singly linked list, push/pop)
├── singly_linklist.cpp    # Singly linked list (creation, input, operator<<, free)
├── doubly_linklist.cpp    # Doubly linked list (creation, bidirectional traversal, free)
├── circular_linklist.cpp  # Circular doubly linked list (creation, circularity)
├── ring_linklist.cpp      # Multiple circular doubly linked lists (rings, advanced pointer manipulation)
```

## File Details

### stack.cpp
- Implements a stack using a singly linked list.
- Supports `push` (add to top) and `pop` (remove from top) operations.
- Demonstrates LIFO (Last-In-First-Out) behavior.
- Shows memory management with dynamic allocation and deletion.
- Main function tests stack operations and prints the stack after popping.

### queue.cpp
- Implements a queue using a singly linked list.
- Supports `push` (enqueue at end) and `pop` (dequeue from front) operations.
- Demonstrates FIFO (First-In-First-Out) behavior.
- Uses a global pointer to track the head for printing.
- Main function tests queue operations and prints the queue.

### singly_linklist.cpp
- Implements a singly linked list with dynamic node creation.
- Supports user input for list size and data.
- Overloads the `<<` operator for easy printing of the list.
- Includes a method to free memory and avoid leaks.
- Demonstrates list traversal, memory management, and operator overloading.

### doubly_linklist.cpp
- Implements a doubly linked list (nodes have left and right pointers).
- Supports creation, traversal from right to left, and memory freeing.
- Demonstrates bidirectional traversal and dynamic memory management.
- Main function prints the list in reverse and after freeing memory.

### circular_linklist.cpp
- Implements a circular doubly linked list.
- Last node points back to the first, forming a loop.
- Supports creation and infinite traversal (prints until break condition).
- Demonstrates circular structure and pointer manipulation.

### ring_linklist.cpp
- Creates multiple circular doubly linked lists (rings).
- Connects rings together to form a flexible pipe-like structure.
- Supports user-defined number of rings and nodes per ring.
- Demonstrates advanced pointer manipulation and multi-list connections.
- Prints each ring's data in alternating directions (right/left).

### tempCodeRunnerFile.cpp
- Temporary file, may be used for quick code tests or debugging.

## Key Learnings
- How to implement and manipulate core data structures in C++
- Dynamic memory management and pointer operations
- Traversal, insertion, and deletion in various list types
- Operator overloading for custom printing
- Advanced structures like circular and ring-linked lists
- Practical experience with both basic and complex pointer logic

## How to Run
1. Compile any file using g++:
   ```bash
   g++ stack.cpp -o stack
   ./stack
   ```
2. Follow prompts for input where required and observe the output.

## About This Repository
This repository is a reflection of my progress and curiosity in data structures and C++ programming. Each file is a step in building a strong foundation for more advanced algorithms and systems.

---

Thank you for exploring my data structures journey!

--- END README ---
===== END REPO =====

===== REPO: dw-project =====
URL: https://github.com/SaudDSxAI/dw-project

--- README ---
# Data Warehousing Project: My Learning Journey

Welcome to my Data Warehousing project! This notebook documents my hands-on struggle and progress in understanding, cleaning, transforming, and loading data for warehousing. Here, I share the practical steps, challenges, and solutions I encountered while working with real-world datasets and MySQL.

## Project Overview
This project is focused on the end-to-end process of data warehousing, including:
- Data extraction and cleaning from multiple CSV files
- Handling missing values and data inconsistencies
- Transforming raw data into fact and dimension tables
- Loading processed data into a MySQL data warehouse
- Writing and testing SQL queries for data management
- Visualizing data using Python and word clouds

## Notebook Highlights
- **File Management:** Automated copying and updating of CSV files for staging and processing.
- **Data Cleaning:** Searched for missing values, filled empty cells, and removed unnecessary rows/columns.
- **Schema Design:** Broke down data into fact and dimension tables, renamed columns for clarity, and ensured consistency.
- **ETL Process:** Loaded cleaned data into MySQL tables, handled errors, and iterated on schema changes.
- **SQL Practice:** Practiced essential SQL commands for altering tables, adding/dropping keys, and transferring data between databases.
- **Visualization:** Used Python and word clouds to visualize text data from the warehouse.

## Key Learnings & Struggles
- The importance of thorough data cleaning before loading into a warehouse
- How to design and separate fact and dimension tables for efficient querying
- Handling real-world data quirks, missing values, and schema mismatches
- Writing robust ETL scripts and troubleshooting MySQL connection issues
- Gaining confidence with SQL for data warehousing operations

## How to Run
1. Make sure you have Python, pandas, and MySQL installed.
2. Update file paths and MySQL credentials as needed in the notebook.
3. Run the notebook cells sequentially to follow the ETL and warehousing process.

## About This Project
This project is a reflection of my growth and persistence in learning data warehousing. It captures both the challenges and the satisfaction of building a working data warehouse from scratch.

---

Thank you for checking out my journey!
--- END README ---
===== END REPO =====

===== REPO: face-recog-entry =====
URL: https://github.com/SaudDSxAI/face-recog-entry
(No README)
===== END REPO =====

===== REPO: first-html =====
URL: https://github.com/SaudDSxAI/first-html

--- README ---
# My First HTML Portfolio

Welcome to my first HTML project! This repository showcases my journey in learning the basics of web development using HTML. Here, I have created a personal profile page and a contact form, experimenting with tables, lists, images, and forms to build a visually structured and interactive web page.

## Project Overview
- **index.html:** Main profile page with personal information, skills, work experience, and social media links.
- **html contact.html:** Contact form page for visitors to reach out via email.

## Features
- Profile section with images and personal details
- Skills and experience listed using tables and lists
- Social media links with icons
- Contact form for direct communication
- Use of HTML tables for layout and organization
- Experimentation with images, headings, and semantic tags

## What I Learned
- Structuring web pages using HTML elements
- Using tables for layout and data presentation
- Creating forms for user input and email submission
- Embedding images and external links
- Organizing content with lists and headings
- Building a multi-page site with navigation

## How to View
1. Download or clone this repository.
2. Open `index.html` in your web browser to view the profile page.
3. Click the "Contact ME" link to access the contact form.

## About This Project
This project is a reflection of my first steps in web development. It demonstrates my understanding of HTML structure, layout, and basic interactivity. I look forward to expanding my skills with CSS and JavaScript in future projects!

---

Thank you for visiting my HTML portfolio!

--- END README ---
===== END REPO =====

===== REPO: fyp =====
URL: https://github.com/SaudDSxAI/fyp

--- README ---
Agrobot – Autonomous Weed Removal Robot (Code Module)

This repository contains the Arduino/ESP32 code modules for the Agrobot, an autonomous agricultural robot designed for weed detection, removal, and crop monitoring. These code modules handle motor control, sensor data acquisition, and IoT integration, forming the backbone for the robot’s mobility and real-time monitoring capabilities.

Overview

The provided code modules implement the following core functionalities:

Bluetooth-Controlled Mobility

Motor control via Bluetooth commands.

Adjustable speed control for forward, backward, and turning movements.

Smooth directional transitions, including diagonal movements.

MPU6050 Motion Tracking

Real-time acceleration (ax, ay, az) in m/s².

Approximate velocity and position calculation.

Supports integration with navigation and path-planning algorithms.

Blynk IoT Dashboard Integration

Sends sensor data to a remote dashboard for monitoring.

Includes environmental sensors: DHT11 (temperature and humidity), soil moisture, light intensity, and X/Y positional values.

Provides remote control for an LED actuator via Blynk virtual pins.

Ultrasonic Sensor-Based Obstacle Detection

Measures distance using up to six ultrasonic sensors.

Enables obstacle avoidance and safe navigation in agricultural fields.

Encoder-Based Odometry

Tracks wheel rotation to calculate X, Y coordinates and robot orientation (theta).

Supports precise navigation across uneven terrain.

Code Modules
1. Bluetooth Motor Control

Purpose: Receives commands from a Bluetooth device to control motor direction and speed.

Key Features:

Commands: F (forward), B (backward), L (left), R (right), S (stop), G, I, H, J (diagonal motions).

Speed adjustments via numeric inputs 0–9.

Smooth motor operation using analogWrite() for PWM control.

2. MPU6050 Sensor Module

Purpose: Reads accelerometer and gyroscope data for motion tracking.

Key Features:

Converts raw data to acceleration in m/s².

Calculates velocity and approximate displacement.

Outputs real-time X and Y positions to Serial Monitor.

3. Blynk IoT Integration

Purpose: Transmits environmental sensor readings to a Blynk dashboard.

Sensors Integrated:

DHT11: Temperature and humidity

Soil Moisture Sensor

Light Sensor

X/Y positional values

Features:

Remote LED control via Blynk.

Data sent every 2 seconds for real-time monitoring.

4. Ultrasonic Distance Measurement

Purpose: Measures distances around the robot for obstacle detection.

Features:

Supports up to six sensors.

Calculates distance using the pulse duration from trigger/echo pins.

Outputs distances to Serial Monitor for debugging.

5. Encoder-Based Motion Tracking

Purpose: Tracks wheel rotations for accurate position and orientation calculations.

Features:

Converts encoder ticks into distance traveled.

Calculates X, Y coordinates and heading angle (theta).

Supports straight-line motion, turning, and odometry correction.

Hardware Pin Configuration
Module	Pins
Motor Driver	IN1, IN2, IN3, IN4
Motor Encoders	ENCODER_A, ENCODER_B, ENCODER_C, ENCODER_D
Ultrasonic Sensors	Trig1–6, Echo1–6
MPU6050	I2C (SDA, SCL)
DHT11	Pin 4
Soil Moisture	Analog Pin 34
Light Sensor	Analog Pin 35
LED	Pin 4 (digital output)
Bluetooth	Serial2 (ESP32 default)

--- END README ---
===== END REPO =====

===== REPO: ml-dl-proj =====
URL: https://github.com/SaudDSxAI/ml-dl-proj

--- README ---
# Machine Learning & Deep Learning Projects

Welcome to my machine learning and deep learning journey! This repository contains hands-on projects where I explore, implement, and compare various ML and DL techniques on real-world datasets. Each notebook represents a different challenge and learning milestone.

## Table of Contents
- [Overview](#overview)
- [Project Structure](#project-structure)
- [1. Diabetes Prediction](#1-diabetes-prediction)
- [2. Titanic Survival Prediction](#2-titanic-survival-prediction)
- [3. Telco Customer Churn (ML & DL)](#3-telco-customer-churn-ml--dl)
- [Key Learnings](#key-learnings)
- [How to Run](#how-to-run)
- [Future Plans](#future-plans)
- [Acknowledgements](#acknowledgements)

---

## Overview
This repository documents my progress in mastering machine learning and deep learning. I have tackled different datasets and problems, focusing on:
- Data preprocessing and cleaning
- Feature engineering and selection
- Model building, evaluation, and comparison
- Visualization and interpretation

## Project Structure
```
machine_learning/
├── diabetes_prediction.ipynb         # Predicting diabetes using SVM
├── titanic_survival_prediction.ipynb # Predicting Titanic survival using SVM
├── ML-DL.ipynb                      # Telco churn: feature selection, ML & DL
├── ML-DL.txt                        # Notes and learnings
├── README.md                        # This file
```

## 1. Diabetes Prediction
- **Notebook:** `diabetes_prediction.ipynb`
- **Goal:** Predict whether a patient has diabetes based on medical features.
- **Techniques:** Data exploration, standardization, SVM classification, accuracy evaluation, and prediction for new data.
- **Key Steps:**
  - Data loading and exploration
  - Feature scaling
  - Train-test split
  - SVM model training and evaluation
  - Making predictions for new patients

## 2. Titanic Survival Prediction
- **Notebook:** `titanic_survival_prediction.ipynb`
- **Goal:** Predict passenger survival on the Titanic.
- **Techniques:** Data cleaning, encoding, feature selection, SVM classification, and accuracy evaluation.
- **Key Steps:**
  - Handling missing values and encoding categorical data
  - Feature selection
  - Model training and evaluation
  - Survival prediction for new passengers

## 3. Telco Customer Churn (ML & DL)
- **Notebook:** `ML-DL.ipynb`
- **Goal:** Predict customer churn using both machine learning and deep learning models.
- **Techniques:**
  - Data preprocessing, encoding, and normalization
  - Feature selection (chi-squared, wrapper, random forest)
  - Model comparison: Logistic Regression, Random Forest, Gradient Boosting, SVM, k-NN
  - Deep learning with TensorFlow/Keras
  - Visualization of feature importance and model results
- **Key Steps:**
  - Data cleaning and encoding
  - Feature scaling (MinMax, Standard, Robust)
  - Feature selection and visualization
  - Model training, evaluation, and comparison
  - Building and evaluating a neural network

## Key Learnings
- The importance of data preprocessing and feature engineering
- How to select and compare features and models
- Practical experience with both classical ML and modern DL
- Visualization for better understanding and communication

## How to Run
1. Clone this repository:
   ```bash
   git clone <repo-url>
   cd machine_learning
   ```
2. Install required packages:
   ```bash
   pip install pandas numpy scikit-learn matplotlib seaborn tensorflow missingno
   ```
3. Open any notebook in Jupyter or VS Code and run the cells sequentially.

## Future Plans
- Add more datasets and advanced models
- Experiment with hyperparameter tuning and model deployment
- Add more visualizations and explanations

## Acknowledgements
- Kaggle and UCI for datasets
- Scikit-learn, pandas, TensorFlow, and the open-source community

---

This repository is a reflection of my growth and curiosity in the field of data science. I hope it helps and inspires others on a similar path!
--- END README ---
===== END REPO =====

===== REPO: nlp-sem-project =====
URL: https://github.com/SaudDSxAI/nlp-sem-project

--- README ---
Duplicate Question Detection with BERT
This project demonstrates how to detect duplicate questions using a BERT-based deep learning model. The workflow includes data preprocessing, exploratory data analysis, feature engineering, model training, evaluation, and inference.

Features
Cleans and preprocesses question pairs from a CSV dataset.
Performs exploratory data analysis (EDA) and feature engineering.
Tokenizes question pairs using Hugging Face’s BERT tokenizer.
Trains a BERT model for binary classification (duplicate or not).
Evaluates the model using accuracy, F1, precision, recall, and ROC-AUC.
Saves and reloads the trained model for inference.
Provides a function to predict if two new questions are duplicates.
Requirements
Python 3.7+
pandas, numpy, matplotlib, seaborn
scikit-learn
torch
transformers
Usage
Place your dataset (CSV) in the specified path.
Run the notebook cells sequentially:
Data loading and cleaning
EDA and feature engineering
Data splitting
Model training and evaluation
Model saving and loading
Inference on new question pairs

--- END README ---
===== END REPO =====

===== REPO: oop-practice =====
URL: https://github.com/SaudDSxAI/oop-practice

--- README ---
# C++ OOP Practice Collection

## Overview
This repository contains a variety of C++ programs and code snippets focused on Object-Oriented Programming (OOP) concepts. The collection covers class design, inheritance (including multiple and virtual inheritance), operator overloading, friend functions, static/const, virtual functions, and more. Each file demonstrates a specific OOP principle or C++ feature, reflecting my journey in mastering C++ through hands-on practice and experimentation.

## Features
- Demonstrates core OOP concepts: classes, inheritance, polymorphism, encapsulation, and abstraction.
- Includes advanced topics: virtual functions, operator overloading, friend functions, and the diamond problem.
- Modular code: Each file is self-contained and focused on a single concept for easy learning and reference.

## File Explanations

### Assignment1/2021576_saudAhmad.cpp
Implements a simple library management system using a struct. Demonstrates encapsulation, dynamic memory allocation, and basic data handling for books.

### static_const.cpp
Shows the use of constructors, destructors, static variables, and dynamic object arrays. Demonstrates object lifecycle and static variable persistence across function calls.

### friend_fun.cpp
Illustrates the use of friend functions to access private members of a class, breaking encapsulation for specific use cases.

### enum.cpp
Implements a simple algorithm (sum to target) and prints indices. Not directly related to enums, but demonstrates array handling and control flow.

### diamond_problem.cpp
Demonstrates the diamond problem in multiple inheritance and its solution using virtual inheritance. Shows constructor/destructor order and method resolution.

### Operator Overloading/practice1.cpp
Implements operator overloading for the `+` operator in a custom class, allowing intuitive addition of objects.

### Operator Overloading/practice2.cpp
Overloads the `<<` and `>>` operators for custom input/output of a class, enabling easy reading and printing of object data.

### Inheritance1/practice2.cpp
Demonstrates function overriding in inheritance. Shows how derived classes can override base class methods and how to call base class methods explicitly.

### Inheritance1/practice3.cpp
Implements multiple inheritance, showing how a class can inherit from more than one base class and how to resolve method calls.

### Inheritance1/practice4.cpp
Demonstrates the diamond problem in inheritance and how to resolve ambiguity using scope resolution.

### tempCodeRunnerFile.cpp
Contains a commented-out copy constructor for a class, likely used for quick testing or debugging.

### p1.h
Header file for a `Time` class, declaring methods for setting and printing time in different formats. Demonstrates class declaration and encapsulation.

### virtual_fun.cpp
Demonstrates abstract classes and pure virtual functions. Shows constructor/destructor order in inheritance and the use of virtual methods for polymorphism.

## How to Use
1. **Compile:** Use a C++ compiler (e.g., g++) to compile any file.
   - Example: `g++ static_const.cpp -o static_const`
2. **Run:** Execute the compiled program.
   - Example: `./static_const`
3. **Explore:** Modify and experiment with the code to deepen your understanding of C++ OOP concepts.

## My Learning Journey
Through this collection, I learned:
- The practical application of OOP principles in C++.
- How to implement and use advanced C++ features.
- Debugging, code organization, and modular programming.

---
*Created by Saud Ahmad – C++ OOP Learner*

--- END README ---
===== END REPO =====

===== REPO: portfolio =====
URL: https://github.com/SaudDSxAI/portfolio

--- README ---
This repository brings together two complementary applications that showcase the integration of agentic AI, large language models (LLMs), and LangChain with modern web interfaces. The first is an AI assistant that autonomously ingests and summarizes documents and GitHub repositories, transforming static information into a conversational knowledge agent accessible through a Streamlit chat interface. The second is a Streamlit-based portfolio website, designed as a clean and interactive showcase of professional information and projects. Together, they demonstrate how LLM-powered agentic systems can create both dynamic, queryable assistants and polished, user-friendly frontends for presenting personal or organizational profiles.
--- END README ---
===== END REPO =====

===== REPO: opencv-proj =====
URL: https://github.com/SaudDSxAI/opencv-proj

--- README ---
# OpenCV Face Recognition Project

## Overview
This project demonstrates real-time face recognition and image comparison using OpenCV and the `face_recognition` library in Python. It includes scripts for live webcam-based face detection, encoding known faces, and comparing images for facial similarity. The project reflects my journey in computer vision, practical AI, and hands-on experimentation with facial recognition technology.

## Features
- **Real-Time Face Recognition:** Detects and recognizes faces from a webcam feed using pre-encoded images.
- **Image Comparison:** Compares two images to determine if they contain the same person.
- **Modular Code:** Includes reusable classes and functions for encoding, detection, and comparison.
- **User-Friendly Visualization:** Draws bounding boxes and labels on detected faces in real time.

## How It Works
1. **Encoding Faces:**
   - The `SimpleFacerec` class loads and encodes known faces from an images folder.
2. **Live Recognition:**
   - `main_video.py` captures webcam frames, detects faces, and matches them against known encodings, displaying results live.
3. **Image Comparison:**
   - `image_comparison.py` loads two images, encodes the faces, and prints whether they match.

## My Learning Journey
Through this project, I learned:
- How to use OpenCV for image and video processing.
- The basics of face encoding and recognition with the `face_recognition` library.
- Real-time computer vision pipeline design and debugging.
- The importance of modular, reusable code for AI projects.

## Usage Instructions
1. **Install Dependencies:**
   - Required: `opencv-python`, `face_recognition`, `numpy`.
   - Install with: `pip install opencv-python face_recognition numpy`
2. **Prepare Images:**
   - Place known face images in the `images/` directory.
3. **Run Live Recognition:**
   - Execute `main_video.py` to start webcam-based face recognition.
4. **Compare Images:**
   - Use `image_comparison.py` to compare two images for facial similarity.

## File Structure
- `main_video.py`: Real-time face recognition from webcam.
- `simple_facerec.py`: Face encoding and recognition class.
- `image_comparison.py`: Script for comparing two images.
- `images/`: Folder for known face images.

---
*Created by Saud Ahmad – Computer Vision & AI Enthusiast*
--- END README ---
===== END REPO =====

===== REPO: opencv-basics =====
URL: https://github.com/SaudDSxAI/opencv-basics

--- README ---
# OpenCV Basics Project

## Overview
This project is a collection of Python scripts demonstrating fundamental concepts and operations in OpenCV. It covers image reading, color manipulation, drawing, transformations, contour detection, and more. The project reflects my journey in learning computer vision, starting from the basics and building a strong foundation for more advanced applications.

## Features
- **Image Reading & Video Capture:** Load and display images and videos using OpenCV.
- **Color Manipulation:** Change image color spaces and separate color channels.
- **Drawing & Writing:** Draw shapes and write text on images programmatically.
- **Image Transformations:** Apply resizing, rotation, and other geometric transformations.
- **Contour Detection:** Find and visualize contours in images.
- **Utility Functions:** Explore various OpenCV functions for image processing.

## How It Works
1. Each script in the `openCV_py_basics/` folder demonstrates a specific OpenCV concept or technique.
2. Scripts are modular and can be run independently for focused learning and experimentation.
3. Example image (`my.png`) is provided for testing and demonstration.

## My Learning Journey
Through this project, I learned:
- The basics of image and video processing with OpenCV.
- How to manipulate image data and perform common computer vision tasks.
- The importance of hands-on experimentation for mastering new libraries.
- Building reusable code snippets for future computer vision projects.

## Usage Instructions
1. **Install Dependencies:**
   - Required: `opencv-python`, `numpy`.
   - Install with: `pip install opencv-python numpy`
2. **Run Scripts:**
   - Navigate to the `openCV_py_basics/` directory.
   - Run any script (e.g., `python read_image_videos.py`) to see the concept in action.
3. **Experiment:**
   - Modify scripts or use your own images to deepen your understanding.

## File Structure
- `openCV_py_basics/`: Folder containing all basic OpenCV scripts:
  - `read_image_videos.py`: Image/video loading and display
  - `changing_image_color.py`: Color space conversions
  - `color_separation.py`: Channel separation
  - `draw_write_on_image.py`: Drawing and text
  - `image_transformation.py`: Geometric transformations
  - `Contours.py`: Contour detection
  - `some_functions_on_image.py`: Miscellaneous functions
- `my.png`: Example image for testing
- `README.md`: Project overview and instructions

---
*Created by Saud Ahmad – Computer Vision Learner*
--- END README ---
===== END REPO =====

===== REPO: rag-ai =====
URL: https://github.com/SaudDSxAI/rag-ai

--- README ---
# rag-ai
--- END README ---
===== END REPO =====

===== REPO: pythonbasicsforDS =====
URL: https://github.com/SaudDSxAI/pythonbasicsforDS

--- README ---
# pythonbasicsforDS
Python Basics for DATA Science, AI and Development.

--- END README ---
===== END REPO =====

===== REPO: robotic-project-summer =====
URL: https://github.com/SaudDSxAI/robotic-project-summer

--- README ---
# Smart Robot Car Project

## Overview
This project is an Arduino-based smart robot car that can operate in multiple modes: Bluetooth control, self-driving (obstacle avoidance), and line following. The car uses ultrasonic sensors for distance measurement, IR sensors for line detection, and an LCD for user feedback. It is designed to demonstrate a blend of embedded systems, robotics, and real-time control, reflecting my journey in hands-on robotics and automation.

## Features
- **Bluetooth Control:** Remotely control the car's movement and speed using a mobile device.
- **Self-Driving Mode:** The car autonomously avoids obstacles using three ultrasonic sensors.
- **Line Following:** Two line-following algorithms using multiple IR sensors for path tracking.
- **LCD Display:** Real-time feedback and instructions displayed to the user.
- **Modular Code:** Functions for each mode (Bluetooth, self-driving, line following) for easy extension and debugging.

## Hardware Used
- Arduino Uno (or compatible)
- L298N Motor Driver
- 3x Ultrasonic Sensors (HC-SR04)
- 7x IR Sensors
- LiquidCrystal I2C LCD
- Bluetooth Module (e.g., HC-05)
- Motors, Chassis, Power Supply

## Code Structure
- **setup() / loop():** Initializes hardware and manages mode switching based on serial input.
- **bluetooth_controle():** Handles remote commands for movement and speed.
- **self_driving():** Implements obstacle avoidance logic using sensor data.
- **line_following1() / line_following2():** Two different line following strategies.
- **sensor_distance(), speed_controle():** Utility functions for sensor calibration and speed management.

## How It Works
1. **Startup:** LCD greets the user and prompts for Bluetooth connection.
2. **Mode Selection:** Modes are switched via serial commands (e.g., from a mobile app).
3. **Operation:**
   - In Bluetooth mode, the car responds to directional and speed commands.
   - In self-driving mode, it navigates around obstacles.
   - In line-following mode, it tracks lines using IR sensors.
4. **Feedback:** LCD provides real-time status and instructions.

## My Learning Journey
This project was a major step in my robotics learning path. I learned:
- Integrating multiple sensors and actuators with Arduino.
- Writing modular, maintainable embedded code.
- Real-time debugging and troubleshooting hardware/software issues.
- Designing user-friendly feedback systems (LCD, Bluetooth interface).
- The importance of calibration and robust error handling in robotics.

## Getting Started
1. **Wiring:** Connect all sensors, motors, and modules as per the pin assignments in the code.
2. **Upload:** Flash the `PROJECT_CAR.ino` code to your Arduino.
3. **Power Up:** Supply power to the car and connect via Bluetooth (if desired).
4. **Control:** Use a mobile app or serial monitor to send commands and switch modes.

## Pin Assignments
- **Motors:** 3, 5, 6, 9
- **Ultrasonic Sensors:** Trig (4, 7, 8), Echo (10, 11, 12)
- **IR Sensors:** 2, 13, 14, 15, 16, 17, 18
- **LCD:** I2C (0x27)

## Acknowledgements
- Inspired by open-source robotics projects and the Arduino community.
- Special thanks to online tutorials and forums for troubleshooting help.

---
*Made by Saud Ahmad – Robotics & AI Enthusiast*

--- END README ---
===== END REPO =====

===== REPO: SaudDSxAI =====
URL: https://github.com/SaudDSxAI/SaudDSxAI

--- README ---
<!-- Profile Header -->
<h1 align="center">Hi, I'm <span style="color:#0078D4">Saud Ahmad</span></h1>
<h3 align="center">Data Scientist ▸ AI & ML/DL Engineer ▸ Agentic AI Innovator</h3>

<p align="center">
  <img src="https://i.pinimg.com/originals/81/17/8b/81178b47a8598f0c81c4799f2cdd4057.gif" alt="coding" width="700"/>
</p>

---

<p align="center">
  <img src="https://komarev.com/ghpvc/?username=saud0346&label=Profile%20views&color=0e75b6&style=flat" alt="Profile Views"/>
</p>

---

## ▸ 🤖 Ask My AI Assistant  

<p align="center">
  <a href="https://portfolio-zaofk9heuxakkvvbfpseoh.streamlit.app/" target="_blank">
    <img src="https://img.shields.io/badge/💬_Chat_with_My_AI_Assistant-0078D4?style=for-the-badge&logo=openai&logoColor=white" alt="AI Assistant"/>
  </a>
</p>

<p align="center">
  ➤ Explore my **AI Assistant** — ask about my <b>CV ▸ Skills ▸ Projects ▸ Experience</b> in real-time.
</p>

---

## ▸ About Me  
- ▹ Passionate **Data Scientist & AI Engineer** building intelligent systems.  
- ▹ Experienced in **Machine Learning, Deep Learning, NLP, Computer Vision, and Agentic AI**.  
- ▹ Specialized in **LLM-powered apps, autonomous agents, and AI-driven analytics**.  
- ▹ End-to-end expertise: from **data pipelines → insights → production-ready AI systems**.  
- ▹ Continuously exploring the cutting edge of **Generative AI & Multi-Agent Systems**.  
- ▹ Open to collaborations in **AI innovation, data science, and open-source contributions**.  

---

## ▸ Core Skills & Tools  
<p align="center">
  <!-- Agentic AI & LLM -->
  <img src="https://img.shields.io/badge/LangChain-000000?style=for-the-badge&logo=chainlink&logoColor=white"/>
  <img src="https://img.shields.io/badge/LangGraph-4B0082?style=for-the-badge&logo=graph&logoColor=white"/>
  <img src="https://img.shields.io/badge/Transformers-F7DF1E?style=for-the-badge&logo=huggingface&logoColor=black"/>
  <img src="https://img.shields.io/badge/BERT-121212?style=for-the-badge&logo=google&logoColor=white"/>
  <img src="https://img.shields.io/badge/Streamlit-FF4B4B?style=for-the-badge&logo=streamlit&logoColor=white"/>

  <!-- ML/DL -->
  <img src="https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white"/>
  <img src="https://img.shields.io/badge/Scikit--Learn-F7931E?style=for-the-badge&logo=scikit-learn&logoColor=white"/>
  <img src="https://img.shields.io/badge/TensorFlow-FF6F00?style=for-the-badge&logo=tensorflow&logoColor=white"/>
  <img src="https://img.shields.io/badge/PyTorch-EE4C2C?style=for-the-badge&logo=pytorch&logoColor=white"/>
  <img src="https://img.shields.io/badge/Numpy-013243?style=for-the-badge&logo=numpy&logoColor=white"/>
  <img src="https://img.shields.io/badge/Pandas-150458?style=for-the-badge&logo=pandas&logoColor=white"/>
  <img src="https://img.shields.io/badge/Matplotlib-11557C?style=for-the-badge&logo=matplotlib&logoColor=white"/>

  <!-- Data Engineering -->
  <img src="https://img.shields.io/badge/SQL-4479A1?style=for-the-badge&logo=mysql&logoColor=white"/>
  <img src="https://img.shields.io/badge/ETL-006699?style=for-the-badge&logo=apacheairflow&logoColor=white"/>

  <!-- CV & Infra -->
  <img src="https://img.shields.io/badge/OpenCV-5C3EE8?style=for-the-badge&logo=opencv&logoColor=white"/>
  <img src="https://img.shields.io/badge/Linux-FCC624?style=for-the-badge&logo=linux&logoColor=black"/>
  <img src="https://img.shields.io/badge/Git-F05032?style=for-the-badge&logo=git&logoColor=white"/>
</p>

---

## ▸ Highlight Projects  

### ⟶ Agentic AI & LLM Systems  
- ⮞ **Agentic AI Projects** – Autonomous multi-agent workflows with LangChain/LangGraph.  
- ⮞ **Retail Insight Generator** – LLM converts natural language → SQL queries → instant insights.  
- ⮞ **Portfolio AI Assistant** – Conversational repo/document Q&A powered by LLMs.  
- ⮞ **Duplicate Question Detection (BERT)** – Semantic similarity with transformer models.  

### ⟶ Machine Learning & Deep Learning  
- ⮞ **Breast Cancer Classification** – Neural networks for medical data classification.  
- ⮞ **Diabetes, Titanic, Telco Churn** – Classic ML/DL workflows with feature engineering & model comparison.  
- ⮞ **Traffic Accident Analysis** – Real-world data insights using pandas & ML.  

### ⟶ Computer Vision & Data Engineering  
- ⮞ **Access Vision** – Face recognition entry system with real-time logging.  
- ⮞ **OpenCV Projects** – Image/video pipelines, transformations, contour detection.  
- ⮞ **Data Warehousing Project** – ETL pipeline, schema design, MySQL analytics.  

---

## ▸ GitHub Stats  
<p align="center">
  <img src="https://github-readme-stats.vercel.app/api?username=SaudDSxAI&show_icons=true&theme=tokyonight&hide_border=true&rank_icon=github" alt="GitHub Stats" height="165"/>
  <img src="https://github-readme-stats.vercel.app/api/top-langs/?username=SaudDSxAI&layout=compact&theme=tokyonight&hide_border=true" alt="Top Languages" height="165"/>
</p>

---

## ▸ Contact Me  

<p align="center">
  <a href="mailto:saud.ahmad346@outlook.com"><img src="https://img.shields.io/badge/Email-0078D4?style=for-the-badge&logo=microsoftoutlook&logoColor=white"/></a>
  <a href="https://www.linkedin.com/in/saud-ahmad-286000229/" target="_blank"><img src="https://img.shields.io/badge/LinkedIn-0A66C2?style=for-the-badge&logo=linkedin&logoColor=white"/></a>
  <a href="https://github.com/SaudDSxAI" target="_blank"><img src="https://img.shields.io/badge/GitHub-181717?style=for-the-badge&logo=github&logoColor=white"/></a>
  <a href="https://www.youtube.com/channel/UCSBnun1ilmIbVvjKqeQiVBw" target="_blank"><img src="https://img.shields.io/badge/YouTube-FF0000?style=for-the-badge&logo=youtube&logoColor=white"/></a>
</p>

---

<p align="center">
  <b>▸ Let's connect and build the future of AI together!</b>
</p>

--- END README ---
===== END REPO =====

===== REPO: robotics001 =====
URL: https://github.com/SaudDSxAI/robotics001

--- README ---
# Robotics001


Line-following Robot:

Code for building a line-following robot using Arduino and IR sensors.
The robot can detect and follow a line on the ground, adjusting its direction to stay on course.
The code is well-commented and includes detailed explanations of how the IR sensors detect the line and how the motor driver controls the robot's movement.
Calibration instructions are provided to help you fine-tune the robot's performance based on your specific setup.



Obstacle Avoiding Robot:

Code for creating an obstacle-avoiding robot using ultrasonic sensors and Arduino.
The robot can detect obstacles in its path and adjust its direction to avoid collisions.
Detailed comments and explanations are included to help you understand how the ultrasonic sensors measure distances and how the robot's logic decides on movement actions.
Tips for improving the robot's obstacle detection and avoidance capabilities.




RC Robot Using PS3 Controller with ESP32:

Code for controlling a robot using a PS3 controller connected to an ESP32.
The ESP32 processes inputs from the PS3 controller to remotely control the robot's movements.
Clear instructions on how to pair the PS3 controller with the ESP32 and configure the ESP32 to receive commands.
Well-commented code to help you understand how the controller inputs are mapped to motor actions and how to modify the code for your specific needs.




HC-05 Bluetooth Module Controlled Robot:

Code for controlling a robot using an HC-05 Bluetooth module connected to an Arduino.
The HC-05 module receives commands from a mobile app, allowing you to control the robot remotely.
Detailed instructions on how to set up the HC-05 module, pair it with the mobile app, and configure the Arduino to interpret the received commands.
Simplified and well-commented code to help you understand the communication between the mobile app and the Arduino, and how to map commands to motor actions.




MPU-6050 Sensor Integration with Arduino:

This repository includes a project that demonstrates how to interface an MPU-6050 sensor with an Arduino. The MPU-6050 is a 6-axis motion tracking device that combines a 3-axis gyroscope and a 3-axis accelerometer. This project shows how to read data from the sensor and map it to a usable format.

--- END README ---
===== END REPO =====

===== REPO: sem-proj-tictactoe =====
URL: https://github.com/SaudDSxAI/sem-proj-tictactoe

--- README ---
# Quiz Tic-Tac-Toe Project (C++)

Welcome to my Quiz Tic-Tac-Toe project! This C++ program is a creative twist on the classic tic-tac-toe game, combining it with a quiz system. Each move on the tic-tac-toe grid is determined by answering a randomly selected question. The project demonstrates my skills in C++ programming, user interaction, randomization, and game logic.

## Project Overview
- **Language:** C++
- **File:** `103project.cpp`
- **Concept:** Play tic-tac-toe, but each cell is filled only if you answer a quiz question correctly. The game features a welcoming animation, a grid display, and a set of 29 unique questions covering general knowledge, science, and religion.

## Features
- Animated welcome screen using ASCII art and timed output
- 3x3 tic-tac-toe grid, displayed with custom formatting
- 29 unique quiz questions, randomly assigned to grid positions
- Each move requires answering a question; correct answers fill the cell with 'T' (True), incorrect with 'F' (False)
- Win/lose logic based on tic-tac-toe rules (three in a row of 'T' or 'F')
- Replay and exit options after each game
- Error handling for repeated moves and invalid input

## What I Practiced & Learned
- Advanced use of functions and modular code in C++
- Random number generation and avoiding repetition
- User input validation and error handling
- Console-based UI with ASCII art and grid drawing
- Game logic for win/lose conditions and replay
- Combining knowledge quizzes with classic games for engagement

## How to Run
1. Make sure you are on Windows (uses `<windows.h>` for `Sleep` and `system` commands).
2. Compile the code with a C++ compiler (e.g., g++):
   ```bash
   g++ 103project.cpp -o quiz-tictactoe
   ./quiz-tictactoe
   ```
3. Follow the on-screen instructions to play and answer questions.

## About This Project
This project is a reflection of my creativity and problem-solving in C++. It combines game development, quiz logic, and user experience in a single console application. I hope you enjoy playing and testing your knowledge!

---

Thank you for checking out my Quiz Tic-Tac-Toe project!

--- END README ---
===== END REPO =====

===== REPO: sql-with-llm =====
URL: https://github.com/SaudDSxAI/sql-with-llm

--- README ---
Retail Insight Generator

The Retail Insight Generator is a Streamlit-based application that enables users to query retail data in plain English. By leveraging large language models for natural language to SQL translation, the app converts user questions into executable SQL queries, runs them against a retail database, and returns actionable insights.

With its intuitive interface, business users can type queries such as "Show me the maximum sales in the last quarter" and instantly view both the generated SQL and the corresponding results. This removes the barrier of SQL expertise and makes data exploration accessible to a wider audience.

Key Features

Natural Language to SQL — Translate business questions into SQL queries automatically.

Instant Data Insights — Run queries and view results in a clean, interactive table.

Simple Interface — Streamlit-based UI with minimal setup and ease of use.

Retail Focused — Designed for sales, revenue, and performance analysis.

Tech Highlights

Streamlit for the frontend and user interaction.

LLM-powered SQL generation.

Modular backend with a separate utility handling SQL planning and execution.

--- END README ---
===== END REPO =====

===== REPO: sem-project =====
URL: https://github.com/SaudDSxAI/sem-project

--- README ---
# ES304 Project: Data Preprocessing, Visualization, and Algorithms

Welcome to my ES304 project! This notebook documents my journey through large-scale data preprocessing, visualization, and the implementation of machine learning and data mining algorithms. The project focuses on handling real-world energy consumption datasets, extracting insights, and applying advanced techniques for analysis.

## Project Overview
- **Goal:** Analyze and extract insights from half-hourly and daily energy consumption data for thousands of households.
- **Datasets:**
  - Half-hourly and daily energy usage CSV files (111 blocks each)
  - Household information file
- **Techniques:** Data preprocessing, aggregation, visualization, Random Forest regression, and Apriori association rule mining

## Notebook Highlights
- Automated loading and merging of over 100 CSV files
- Data cleaning, aggregation, and feature extraction
- Visualization of energy statistics (mean, median, max, sum) across households
- Creation of summary files for total and per-household consumption
- Statistical analysis (mean, std, max) of energy usage
- Random Forest regression for household identification
- Apriori algorithm for association rule mining

## Key Learnings & Challenges
- Efficiently handling and processing large numbers of files
- Aggregating and summarizing data for thousands of entities
- Visualizing complex data distributions
- Implementing and interpreting machine learning and data mining algorithms
- Troubleshooting data inconsistencies and memory issues

## How to Run
1. Make sure you have Python and the required libraries installed:
   ```bash
   pip install pandas numpy matplotlib scikit-learn mlxtend
   ```
2. Update file paths as needed in the notebook.
3. Run the notebook cells sequentially to follow the workflow and experiment with the code.

## About This Project
This notebook is a reflection of my growth in data engineering, analysis, and algorithmic thinking. It demonstrates the end-to-end process from raw data to actionable insights and advanced analytics.

---

Thank you for exploring my ES304 project journey!
--- END README ---
===== END REPO =====

===== REPO: tictactoe-new-logic =====
URL: https://github.com/SaudDSxAI/tictactoe-new-logic

--- README ---
# Tic-Tac-Toe Game in C++ (Console)

## Overview
This project is a console-based Tic-Tac-Toe game implemented in C++. It features a user vs. computer mode, a visually formatted grid, and logic for win, lose, and draw conditions. The project demonstrates array manipulation, game logic, and user interaction in C++, reflecting my journey in building interactive console games and improving my programming skills.

## Features
- **User vs. Computer:** Play against a simple AI that makes moves based on the current board state.
- **Formatted Grid:** The game board is displayed using ASCII art for a clear, user-friendly interface.
- **Win/Lose/Draw Detection:** Automatically checks for game-ending conditions after each move.
- **Replay Option:** Option to play again after a win, loss, or draw.
- **Menu and Input Handling:** Prompts for user input and validates choices.

## How It Works
1. **Start Game:** User is prompted to begin the game.
2. **User Turn:** User selects a cell (1-9) to place their 'O'.
3. **Computer Turn:** The AI ('X') makes its move based on available cells and simple strategy.
4. **Check Conditions:** After each move, the game checks for win, lose, or draw.
5. **Replay:** User can choose to play again or exit after the game ends.

## My Learning Journey
Through this project, I learned:
- How to implement game logic and AI in C++.
- Managing 2D arrays for board representation.
- Handling user input and edge cases.
- Creating interactive, replayable console applications.

## Usage Instructions
1. **Compile:** Use a C++ compiler (e.g., g++) to compile `TICTACTOE.cpp`.
   - Example: `g++ TICTACTOE.cpp -o tictactoe`
2. **Run:** Execute the compiled program.
   - Example: `./tictactoe`
3. **Play:** Follow on-screen prompts to play against the computer.

## File Structure
- `TICTACTOE.cpp`: Main source code for the Tic-Tac-Toe game.
- `README.md`: Project overview, features, and instructions.

---
*Created by Saud Ahmad – C++ Game Developer*


--- END README ---
===== END REPO =====

===== REPO: stats-python =====
URL: https://github.com/SaudDSxAI/stats-python

--- README ---
# Python Statistics & Data Visualization Practice

## Overview
This project is a collection of Python scripts demonstrating fundamental concepts in statistics and data visualization. It covers descriptive statistics, random number generation, covariance, plotting with matplotlib, and histogram creation. The project reflects my journey in learning statistics, Python programming, and data analysis through hands-on practice.

## Features
- **Descriptive Statistics:** Calculate mean, median, mode, average, variance, standard deviation, and range using numpy and scipy.
- **Random Number Generation:** Generate random floats, integers, and select random elements from a list.
- **Covariance Calculation:** Compute covariance between columns of pandas DataFrames.
- **Line Plotting:** Visualize data trends with matplotlib line plots.
- **Histogram Plotting:** Display data distributions using histograms.

## How It Works
- Each script demonstrates a specific statistical or visualization concept:
  - `practice1.py`: Descriptive statistics functions and usage.
  - `practice2.py`: Random number generation and selection.
  - `practice3.py`: Covariance calculation with pandas DataFrames.
  - `practice4.py`: Line plot with custom labels and legends.
  - `practice5.py`: Histogram plotting for data distribution.

## My Learning Journey
Through this project, I learned:
- The basics of descriptive statistics and their implementation in Python.
- How to use numpy, scipy, pandas, and matplotlib for data analysis.
- The importance of visualizing data to understand trends and distributions.
- Writing modular, reusable code for statistical analysis.

## Usage Instructions
1. **Install Dependencies:**
   - Required: `numpy`, `scipy`, `pandas`, `matplotlib`.
   - Install with: `pip install numpy scipy pandas matplotlib`
2. **Run Scripts:**
   - Execute any script (e.g., `python practice1.py`) to see the concept in action.
   - Modify scripts or input data to experiment and deepen your understanding.

## File Structure
- `practice1.py`: Descriptive statistics
- `practice2.py`: Random number generation
- `practice3.py`: Covariance calculation
- `practice4.py`: Line plot example
- `practice5.py`: Histogram example
- `README.md`: Project overview and instructions

---
*Created by Saud Ahmad – Statistics & Data Science Learner*

--- END README ---
===== END REPO =====

===== REPO: tools-for-data-science =====
URL: https://github.com/SaudDSxAI/tools-for-data-science

--- README ---
# tools-for-data-science
--- END README ---
===== END REPO =====

===== REPO: tools-for-data-science-notebook-coursera =====
URL: https://github.com/SaudDSxAI/tools-for-data-science-notebook-coursera
(No README)
===== END REPO =====

